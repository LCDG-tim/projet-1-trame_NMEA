<!DOCTYPE html>
    <html>
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>
                trames NMEA
            </title>
            <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
            <link rel="stylesheet" href="style.css" type="text/css">
            <link rel="stylesheet" href="prism.css" type="text/css">
        </head>
        <body>
            <div class="container" id="container">
                <div class="row">
                    <!-- titre de la page -->
                    <h1>
                        Projet d'approfondissement: trame NMEA
                    </h1>
                </div>
                <div class="row">
                    <div class="button">
                        <button onclick="themeClair()">thème clair</button>
                        <button onclick="themeSombre()">thème sombre</button>
                        <button onclick="texteGrossi()">texte grossi</button>
                        <button onclick="textePetit()">petit texte</button>
                    </div>
                </div>
                <div class="row">
                    <p class="menu">
                        Menu
                    </p>
                </div>
                <div class="row" id="nav-bar">
                    <div class="col-lg-3 col-md-3 col-xs-12">
                        <a href="#rep_quest">Réponses aux questions</a>
                    </div>
                    <div class="col-lg-3 col-md-3 col-xs-12">
                        <a href="#explication_code">Explication de code</a>
                    </div>
                    <div class="col-lg-3 col-md-3 col-xs-12">
                        <a href="#code">Le programme</a>
                    </div>
                    <div class="col-lg-3 col-md-3 col-xs-12">
                        <a href="#Mode-emploie">Mode d'emploi</a>
                    </div>
                </div>
                <div class="row" id="Rep_quest">
                    <!-- première partie -->
                    <h2 id="h2">
                        1) Réponses aux questions
                    </h2>
                </div>
                <div class="row">
                    <!-- première question -->
                    <h3>
                        Que sont les "trames NMEA" ?
                    </h3>
                </div>
                <div class="row">
                    <!-- réponse dans un paragraphe -->
                    <p class="explication">
                        Les <span class="bold">trames NMEA</span> sont très diversifiés, en effets il en existe plus d'une 
                        trentaine qui sont toutes différentes le premier élément de chaque trame
                        fournit des informations sur le type d'équipement utilisé et le type de trame
                        l'heure d'envoie de la réponse, la latitude, la longitude, le type de
                        positionnement le nombre de satélites mobilisés pour le calcul, la précision
                        horizontale l'altitude puis différentes informations souvent vide dans les
                        requêtes GPS et enfin la somme de contrôle de parité, un ou exclusif sur les
                        caractères entre $ et *.
                    </p>
                </div>
                <div class="row">
                    <!-- question 2 -->
                    <h3>
                        Qu'est "l'heure UTC" ?
                    </h3>
                </div>
                <div class="row">
                    <!-- réponse 2 -->
                    <p class="explication">
                        L'<span class="bold">heure UTC</span> (Universel Temps coordonnée ou Universal Temps coordinated) est
                        l'heure de référence internationale. Cette heure est calculée au Bureau
                        International des Poids et Mesure (BIPM) grâce à plusieurs horloges réparties
                        dans des laboratoires nationaux.
                    </p>
                </div>
                <div class="row">
                    <a href="#" class="haut">haut de page</a>
                </div>
                <div class="row" id="explication_code">
                    <!-- deuxième partie -->
                    <h2 id="h2">
                        2) Explication de code
                    </h2>
                </div>
                <div class="row">
                    <div class="col-12">
                        <p class="explication">
                            je ne décrirai pas forcément précisement le code dans dans des paragraphes html distincts car je l'ai déjà fait à l'intérieure de la plupart du code. J'ai donc éviter de faire beaucoup de copier/coller et de faire preuve de redondance.
                        </p>
                    </div>
                </div>
                <div class="row">
                    <div class="col-12">
                        <p class="explication">
                            Tout d'abord le programme importe différents modules qui lui seront utiles. Ces modules sont folium qui forme des cartes interpretables par un navigateur internet, puis le module webbrowser permet au programme d'ouvrir les cartes qui sont sauvegarder dans des fichiers html, ce module n'est utilser que pour cela et le module re est un module qui permet la verifification d'expressions régulières, de format içi le programme va vérifier le format des trames.
                        </p>
                    </div>
                    <div class="col-12">
                        <!-- ajout lignes de code -->
                        <pre>
                            <code class="language-python">
                                # =============================================================================
                                # importations

                                import folium
                                import webbrowser
                                import re
                                # =============================================================================
                            </code>
                        </pre>
                    </div>
                </div>
                <div class="row">
                    <div class="col-12">
                        <p class="explication">
                            Le programme crée d'abord une fonction verif_format_tram qui servira à vérifier si la trame donné en paramètre est un trame NMEA. Cette fonction renvoie un booléen qui est True si la trame est du bon format et False sinon. ^ veut dire que la chaine testée doit commencer par ce qui est décrit après. [$] veut dire que le premier caractère est un dollars il est entre crochet car le $ veut dire qui ce qui le précede est à la fin or ce n'est pas ce que nous voulons. Les crochets signifie un ensemble de caractère [0-9] veut dire tout les chifre 0 à 9. le + après une lettre ou un ensemble veut dire qu'il y en a au moins 1. l'astérique * après un ensemble ou un caractère veut dire qu'il n'y est pas ou plus d'une fois. les virgules sont des caractères invariant c'est à dire que quelle que soit la trame donné toutes les virgules décrites devront figuré. le point . signifie n'importe quel caractère donc .* signifie qu'il y a soit rien soit un ou plusieurs caractère.
                        </p>
                    </div>
                    <div class="col-12">
                        <!-- ajout lignes de code -->
                        <pre>
                            <code class="language-python">
                                def verif_format_tram(string: str) -> bool:
                                    # le programme définie le format d'une trame GPS
                                    regex = "^[$][A-Z]*," + \
                                    "[0-9]*[.][0-9]*," + \
                                    "[0-9]*[.][0-9]*," + \
                                    "[NS]," + \
                                    "[0-9]*[.][0-9]*," + \
                                    "[EW]," + \
                                    "[0-9]," + \
                                    "[0-9]+," + \
                                    "[0-9]+[.][0-9]+," + \
                                    "[0-9]+[.][0-9]+," + \
                                    "M," + \
                                    "[0-9]+[.][0-9]+," + \
                                    "M," + \
                                    ".*," + \
                                    "[*][0-9A-F][0-9A-F]"

                                    # re.search(regex, string) est un Match_object si le regex est correct
                                    # sinon re.search(regex, string) est None
                                    return re.search(regex, string) is not None
                            </code>
                        </pre>
                    </div>
                </div>
                <div class="row">
                    <div class="col-12">
                        <p class="explication">
                            Le programme crée ensuite une classe qui avec différents attributs et méthode qui décomposent les différentes informations données par la trame.
                        </p>
                    </div>
                    <div class="col-12">
                        <!-- ajout lignes code -->
                        <pre>
                            <code class="language-python">
                                class Object_gps:

                                    def __init__(self, trame: str = "") -> None:
                                        """constructeur"""

                                        # assertion
                                        assert isinstance(trame, str), \
                                            "argument trame must be a str, not {}".format(type(trame))
                                        if trame == "":
                                            trame = \
                                                "$GPGGA,085508.375,4804.399,N,00508.792,E,1,12,1.0,0.0" + \
                                                ",M,0.0,M,,*65"

                                        else:
                                            assert not verif_format_tram(trame), "tram non valide"

                                        # le programme sépare les différents élément
                                        list_elt = trame.split(",")

                                        # le programe affectes les élements dans des variables locales
                                        # spécialisées pour nous aider
                                        # l'heure internationale sous la forme hhmmss.sss
                                        heure_UTC = list_elt[1]

                                        # DM pour Degres Minutes latitude sous la forme DDMM.MMMM
                                        latitude_DM = "".join(list_elt[2:4])

                                        # longitude sous la forme DDDMM.MMMM
                                        longitude_DM = "".join(list_elt[4:6])

                                        # le type de trame est l'élement 0 de la trame
                                        self.type_de_trame = list_elt[0]

                                        # l'heure est recomposait à partir de la valeur de la trame
                                        self.heure = "{heure}: {minutes}: {secondes}".format(
                                            heure=heure_UTC[:2],
                                            minutes=heure_UTC[2:4],
                                            # le programe arrondit les secondes à l'unité
                                            secondes=round(float(heure_UTC[4:]))
                                        )

                                        # même procédé que pour l'heure, le programme la recomposent à partir de la trame
                                        self.latitude = "{degres}°{minutes}' {secondes}\" {hemisphere}".format(
                                            degres=int(latitude_DM[:2]),
                                            minutes=int(latitude_DM[2:4]),
                                            # il calcule les secondes à partir des dix-millièmes de
                                            # minutes puis le programe arrondi ce nombre à 3 chiffres après
                                            # la virgule
                                            secondes=round(float(latitude_DM[4:-1]) * 60, 3),
                                            hemisphere=latitude_DM[-1]
                                        )

                                        # même chose pour la longitude
                                        self.longitude = "{degres}°{minutes}' {secondes}\" {E_ou_W}".format(
                                            degres=int(longitude_DM[:3]),
                                            minutes=int(longitude_DM[3:5]),
                                            # même méthode que pour la latitude
                                            secondes=round(float(longitude_DM[5:-1]) * 60, 3),
                                            E_ou_W=longitude_DM[-1]
                                        )

                                        # type de positionnement est l'élément 6 de la tramù
                                        self.type_de_positionnement = list_elt[6]

                                        # le nombre de satalites utilisé pour le calcul est donné par l'élément 7
                                        self.nombre_de_satelites = int(list_elt[7])

                                        # la précision horizontale ou horizontal dilution of precision est l'élément 8
                                        self.précision_horizontal_ou_hdop = float(list_elt[8])

                                        # l'altitude est l'élement 9
                                        self.altitude = "{alt} m".format(
                                            alt=float(list_elt[9])
                                        )

                                        # le programme crée les les coordonnés du point en degrès décimal
                                        # cela est utile pour la suite avec folium
                                        self.list_lat_longDD = [
                                            int(latitude_DM[:2]) + float(latitude_DM[2:-1]) / 60,
                                            int(longitude_DM[:3]) + float(longitude_DM[3:-1]) / 60
                                        ]

                                    # getters, méthodes qui renvoie les différentes valeurs :
                                    def get_type_of_trame(self) -> str:
                                        """getter du type de trame"""
                                        return self.type_de_trame

                                    def get_type_of_pos(self) -> str:
                                        """getter du type de positionnement"""
                                        return self.type_de_positionnement

                                    def get_heure_hh_mm_ss(self) -> str:
                                        """getteur de l'heure UTC"""
                                        return self.heure

                                    def get_latitude_dms(self) -> str:
                                        '''getter de la latitude en degrés minutes secondes'''
                                        return self.latitude

                                    def get_longitude_dms(self) -> str:
                                        """getter de la longitude en degrés minutes secondes"""
                                        return self.longitude

                                    def get_nombre_de_satelites(self) -> int:
                                        """getter du nombre de satalites solicités par le calcul"""
                                        return self.nombre_de_satelites

                                    def get_list_lat_long_dd(self) -> list:
                                        """getter de la liste qui contient la latitude en degré décimal et \
                                        la longitude en degré décimal
                                        """
                                        return self.list_lat_longDD
                            </code>
                        </pre>
                    </div>
                </div>
                <div class="row">
                    <div class="col-12">
                        <p class="explication">
                            Le programme déclare ensuite une autre fonction qui sert à la factorisation du code car le programme crée deux cartes avec le même point donc cette fonction prend en argument une instance de Object_gps et une carte folium et elle place un point au coordonnée du point de la trame donnée pour l'Object_gps donné en argument.
                        </p>
                    </div>
                    <div class="col-12">
                        <!-- ajout lignes de code -->
                        <pre>
                            <code class="language-python">
                                def place_marker(target_map: folium.Map, point_choisi: Object_gps) -> None:
                                    """place un marqeur à l'emplacement de point choisi sur la carte choise"""

                                    # assertions
                                    assert isinstance(target_map, folium.Map), \
                                        "target_map must be a folium.map, not {}".format(type(target_map))
                                    assert isinstance(point_choisi, Object_gps), \
                                        "point_choisi must be a Object_gps, not {}".format(type(point_choisi))

                                    folium.Marker(
                                        # coordonnée du point cible
                                        point_choisi.get_list_lat_long_dd(),
                                        # texte ajouté si l'utilisateur clique sur le marqueur
                                        popup="<b>notre lycée</b>",
                                        # texte afficher quand l'utilisateur survole le marqueur
                                        tooltip="Lycée Charles de Gaulle"
                                    ).add_to(
                                        # carte sur laquelle il l'affiche
                                        target_map
                                    )
                            </code>
                        </pre>
                    </div>
                </div>
                <div class="row">
                    <div class="col-12">
                        <p class="explication">
                            Le programme déclare maintenant une procédure qui forme une carte et qui la sauvegarde dans un fichier html externe et qui ouvre ce fichier.
                        </p>
                    </div>
                    <div class="col-12">
                        <!-- ajout lignes de code -->
                        <pre>
                            <code class="language-python">
                                def carte1(point_choisi: Object_gps):

                                    # il crée un première carte
                                    map_fig_1 = folium.Map(
                                        # centrée sur le point principal
                                        location=point_choisi.get_list_lat_long_dd(),
                                        # zoomer au l'échelle de la ville
                                        zoom_start=15
                                    )

                                    # il place le point indiquer par la trame NMEA
                                    place_marker(map_fig_1, point_choisi)

                                    # il enregistre la carte 1 sous le nom de fichier map1.html
                                    file_path = "map1.html"
                                    map_fig_1.save(file_path)
                                    # l'ouvrir dans le navigateur web par défaut de l'utilsateur
                                    webbrowser.open(file_path)
                            </code>
                        </pre>
                    </div>
                </div>
                <div class="row">
                    <div class="col-12">
                        <p class="explication">
                            Le programme déclare une deuxième procédure qui elle crée une cartes avec le point décrit par la trame et un cercle de 100 km autour.
                        </p>
                    </div>
                    <div class="col-12">
                        <!-- ajout lignes de code -->
                        <pre>
                            <code class="language-python">
                                def carte2(point_choisi: Object_gps):

                                    # il crée une carte
                                    map_fig_2 = folium.Map(
                                        # centrée aussi sur le point
                                        location=point_choisi.get_list_lat_long_dd(),
                                        # et un peu plus dézoomer que la première à l'échelle peu supérieur au
                                        # département
                                        zoom_start=8
                                    )

                                    # il place le point
                                    place_marker(map_fig_2, point_choisi)

                                    # il crée un cercle de centre le point de rayon 100 000 m soit 100km
                                    # il rempli le disque de la couleur spécifier
                                    folium.Circle(
                                        location=point_choisi.get_list_lat_long_dd(),
                                        # rayon du cercle en mètre 100km = 100 000m
                                        radius=100_000,
                                        # texte affiché s'il y a un clic sur la zone
                                        popup="zone autorisée",
                                        # couleur du cercle
                                        color="red",
                                        # si le disque du cercle est rempli
                                        fill=True,
                                        # la couleur du disque
                                        fill_color='red'
                                    ).add_to(map_fig_2)
                                    # il ajoute l'élément à la carte (add_to)

                                    # il enregistre la carte 2 sous le nom de fichier map2.html
                                    file_path = "map2.html"
                                    map_fig_2.save(file_path)
                                    # l'ouvrir dans le navigateur web par défaut de l'utilsateur
                                    webbrowser.open(file_path)

                            </code>
                        </pre>
                    </div>
                </div>
                <div class="row">
                    <div class="col-12">
                        <p class="explication">
                            Le programme principal demande à l'utilsateur une trame. Si l'utilsateur n'en rentre pas le programme prendra la tram du lycée Charles de Gaulle sinon si l'utilsateur rentre une trame, celle - ci est vérifier par la fonction verif_format_tram déclare plus tôt et dans le cas ou cette trame n'est pas valable le programme la remande à l'utilisateur qui pourra toujours utiliser la trame par défaut en ne metant rien.
                        </p>
                    </div>
                    <div class="col-12">
                        <!-- ajout lignes de code -->
                        <pre>
                            <code class="language-python">
                                # trame NMEA GPS du lycée : "$GPGGA,085508.375,4804.399,N,00508.792,E,1,12,1.0,0.0,M,0.0,M,,*65"

                                trame = input("veuillez insérer votre trame NMEA : (sinon entrer) ")

                                while not verif_format_tram(trame) and trame != "":
                                    trame = input(
                                        "trame non valide, veuillez vérifier votre trame puis resaisissez "
                                    )
                            </code>
                        </pre>
                    </div>
                </div>
                <div class="row">
                    <div class="col-12">
                        <p class="explication">
                            Le programme définit ensuite l'Object_gps tiré de la trame rentrée ou alors si la trame est vide l'objet est ciblé par rapport au lycée.
                        </p>
                    </div>
                    <div class="col-12">
                        <!-- ajout lignes de code -->
                        <pre>
                            <code class="language-python">
                                # point_cloisie est une instance de Object_gps qui décomposent les infos
                                # de la trame donnée en argument
                                point_choisi = Object_gps(trame)
                            </code>
                        </pre>
                    </div>
                </div>
                <div class="row">
                    <div class="col-12">
                        <p class="explication">
                            Le programme lance ensuiter les deux procédures de création des cartes
                        </p>
                    </div>
                    <div class="col-12">
                        <!-- ajout lignes de code -->
                        <pre>
                            <code class="language-python">
                                carte1(point_choisi)
                                carte2(point_choisi)                            
                            </code>
                        </pre>
                    </div>
                </div>
                <div class="row">
                    <a href="#" class="haut">haut de page</a>
                </div>
                <div class="row"  id="code">
                    <h2>
                        3) Tout le programme
                    </h2>
                </div>
                <div class="row">
                    <form action="trame.zip" method="get">
                        <button type="submit" class="dl">
                            Télécharger
                        </button>
                    </form>
                </div>
                <div class="row">
                    <div class="col-12">
                        <pre>
                            <code class="language-python">
                                # -*- coding: utf-8 -*-
                                # le \ permet de continuer la ligne précédentes à la ligne suivantes
                                # les il signifie le programme


                                # =============================================================================
                                # importations

                                import folium
                                import webbrowser
                                import re
                                # =============================================================================

                                """

                                Quelques renseignements:

                                les trames NMEA sont très diversifiés, en effets il en existe plus d'une
                                trentaine qui sont toutes différentes le premier élément de chaque trame
                                fournit des informations sur le type d'équipement utilisé et le type de trame
                                l'heure d'envoie de la réponse, la latitude, la longitude, le type de
                                positionnement le nombre de satélites mobilisés pour le calcul, la précision
                                horizontale l'altitude puis différentes informations souvent vide dans les
                                requêtes GPS et enfin la somme de contrôle de parité, un simple XOR sur les
                                caractères entre $ et *

                                L'heure UTC (Universel Temps coordonnée ou Universal Temps coordinated) est
                                l'heure de référence internationale. Cette heure est calculée au Bureau
                                International des Poids et Mesure (BIPM) grâce à plusieurs horloges réparties
                                dans des laboratoires nationaux.

                                """


                                def verif_format_tram(string: str) -> bool:
                                    # le programme définie le format d'une trame GPS
                                    regex = "^[$][A-Z]*," + \
                                        "[0-9]*[.][0-9]*," + \
                                        "[0-9]*[.][0-9]*," + \
                                        "[NS]," + \
                                        "[0-9]*[.][0-9]*," + \
                                        "[EW]," + \
                                        "[0-9]," + \
                                        "[0-9]+," + \
                                        "[0-9]+[.][0-9]+," + \
                                        "[0-9]+[.][0-9]+," + \
                                        "M," + \
                                        "[0-9]+[.][0-9]+," + \
                                        "M," + \
                                        ".*," + \
                                        "[*][0-9A-F][0-9A-F]"

                                    # re.search(regex, string) est un Match_object si le regex est correct
                                    # sinon re.search(regex, string) est None
                                    return re.search(regex, string) is not None


                                class Object_gps:

                                    def __init__(self, trame: str = "") -> None:
                                        """constructeur"""

                                        # assertion
                                        assert isinstance(trame, str), \
                                            "argument trame must be a str, not {}".format(type(trame))
                                        if trame == "":
                                            trame = \
                                                "$GPGGA,085508.375,4804.399,N,00508.792,E,1,12,1.0,0.0" + \
                                                ",M,0.0,M,,*65"

                                        else:
                                            assert not verif_format_tram(trame), "tram non valide"

                                        # le programme sépare les différents élément
                                        list_elt = trame.split(",")

                                        # le programe affectes les élements dans des variables locales
                                        # spécialisées pour nous aider
                                        # l'heure internationale sous la forme hhmmss.sss
                                        heure_UTC = list_elt[1]

                                        # DM pour Degres Minutes latitude sous la forme DDMM.MMMM
                                        latitude_DM = "".join(list_elt[2:4])

                                        # longitude sous la forme DDDMM.MMMM
                                        longitude_DM = "".join(list_elt[4:6])

                                        self.type_de_trame = list_elt[0]

                                        self.heure = "{heure}: {minutes}: {secondes}".format(
                                            heure=heure_UTC[:2],
                                            minutes=heure_UTC[2:4],
                                            # le programe arrondit les secondes à l'unité
                                            secondes=round(float(heure_UTC[4:]))
                                        )

                                        self.latitude = "{degres}°{minutes}' {secondes}\" {hemisphere}".format(
                                            degres=int(latitude_DM[:2]),
                                            minutes=int(latitude_DM[2:4]),
                                            # il calcule les secondes à partir des dix-millièmes de
                                            # minutes puis le programe arrondi ce nombre à 3 chiffres après
                                            # la virgule
                                            secondes=round(float(latitude_DM[4:-1]) * 60, 3),
                                            hemisphere=latitude_DM[-1]
                                        )

                                        self.longitude = "{degres}°{minutes}' {secondes}\" {E_ou_W}".format(
                                            degres=int(longitude_DM[:3]),
                                            minutes=int(longitude_DM[3:5]),
                                            # même méthode que pour la latitude
                                            secondes=round(float(longitude_DM[5:-1]) * 60, 3),
                                            E_ou_W=longitude_DM[-1]
                                        )

                                        self.type_de_positionnement = list_elt[6]

                                        self.nombre_de_satelites = int(list_elt[7])

                                        self.précision_horizontal_ou_hdop = float(list_elt[8])

                                        self.altitude = "{alt} m".format(
                                            alt=float(list_elt[9])
                                        )

                                        self.list_lat_longDD = [
                                            int(latitude_DM[:2]) + float(latitude_DM[2:-1]) / 60,
                                            int(longitude_DM[:3]) + float(longitude_DM[3:-1]) / 60
                                        ]

                                    # getteurs :
                                    def get_type_of_trame(self) -> str:
                                        """getter du type de trame"""
                                        return self.type_de_trame

                                    def get_type_of_pos(self) -> str:
                                        """getter du type de positionnement"""
                                        return self.type_de_positionnement

                                    def get_heure_hh_mm_ss(self) -> str:
                                        """getteur de l'heure UTC"""
                                        return self.heure

                                    def get_latitude_dms(self) -> str:
                                        '''getter de la latitude en degrés minutes secondes'''
                                        return self.latitude

                                    def get_longitude_dms(self) -> str:
                                        """getter de la longitude en degrés minutes secondes"""
                                        return self.longitude

                                    def get_nombre_de_satelites(self) -> int:
                                        """getter du nombre de satalites solicités par le calcul"""
                                        return self.nombre_de_satelites

                                    def get_list_lat_long_dd(self) -> list:
                                        """getter de la liste qui contient la latitude en degré décimal et \
                                        la longitude en degré décimal
                                        """
                                        return self.list_lat_longDD


                                def place_marker(target_map: folium.Map, point_choisi: Object_gps) -> None:
                                    """place un marqeur à l'emplacement de point choisi sur la carte choise"""

                                    # assertions
                                    assert isinstance(target_map, folium.Map), \
                                        "target_map must be a folium.map, not {}".format(type(target_map))
                                    assert isinstance(point_choisi, Object_gps), \
                                        "point_choisi must be a Object_gps, not {}".format(type(point_choisi))

                                    folium.Marker(
                                        # coordonnée du point cible
                                        point_choisi.get_list_lat_long_dd(),
                                        popup="<b>notre lycée</b>",
                                        tooltip="Lycée Charles de Gaulle"
                                    ).add_to(
                                        # carte sur laquelle il l'affiche
                                        target_map
                                    )


                                def carte1(point_choisi: Object_gps):

                                    # il crée un première carte
                                    map_fig_1 = folium.Map(
                                        # centrée sur le point principal
                                        location=point_choisi.get_list_lat_long_dd(),
                                        # zoomer au l'échelle de la ville
                                        zoom_start=15
                                    )

                                    # il place le point indiquer par la trame NMEA
                                    place_marker(map_fig_1, point_choisi)

                                    # il enregistre la carte 1
                                    file_path = "map1.html"
                                    map_fig_1.save(file_path)
                                    webbrowser.open(file_path)


                                def carte2(point_choisi: Object_gps):

                                    # il crée une carte
                                    map_fig_2 = folium.Map(
                                        # centrée aussi sur le point
                                        location=point_choisi.get_list_lat_long_dd(),
                                        # et un peu plus dézoomer que la première à l'échelle peu supérieur au
                                        # département
                                        zoom_start=8
                                    )

                                    # il place le point
                                    place_marker(map_fig_2, point_choisi)

                                    # il crée un cercle de centre le point de rayon 100 000 m soit 100km
                                    # il rempli le disque de la couleur spécifier
                                    folium.Circle(
                                        location=point_choisi.get_list_lat_long_dd(),
                                        # rayon du cercle en mètre
                                        radius=100_000,
                                        # texte affiché s'il y a un clic sur la zone
                                        popup="zone autorisée",
                                        # couleur du cercle
                                        color="red",
                                        # si le disque du cercle est rempli
                                        fill=True,
                                        # la couleur du disque
                                        fill_color='red'
                                    ).add_to(map_fig_2)
                                    # il ajoute l'élément à la carte (add_to)

                                    # il sauvegarde la carte 2
                                    file_path = "map2.html"
                                    map_fig_2.save(file_path)
                                    webbrowser.open(file_path)


                                # programme principal
                                if __name__ == "__main__":

                                    # trame NMEA GPS du lycée : "$GPGGA,085508.375,4804.399,N,00508.792,E,1,12,1.0,0.0,M,0.0,M,,*65"

                                    trame = input("veuillez insérer votre trame NMEA : (sinon entrer) ")

                                    while not verif_format_tram(trame) and trame != "":
                                        trame = input(
                                            "trame non valide, veuillez vérifier votre trame puis resaisissez "
                                        )

                                    # point_cloisie est une instance de Object_gps qui décomposent les infos
                                    # de la trame donnée en argument
                                    point_choisi = Object_gps(trame)

                                    carte1(point_choisi)
                                    carte2(point_choisi)
                            </code>
                        </pre>
                    </div>
                </div>
                <div class="row">
                    <a href="#" class="haut">haut de page</a>
                </div>
                <div class="row" id="Mode-emploie">
                    <h2>
                        4) Mode d'emploi
                    </h2>
                </div>
                <div class="row">
                    <p class="explication">
                        Pour commencer, veuillez lancer tram_NMEA.py puis dans la console, si vous avez une trame NMEA à proposer à la machine vous pouvez l'insérer à ce moment le programme vérifiera sa validité pour continuer. Si vous n'avez pas de trame NMEA à proposer vous pouvez presser la touche entrer.
                    </p>
                </div>
                <div class="row">
                    <div class="col-12">
                        <pre>
                            <code class="language-python">
                                In [1]: runfile('C:/Users/Elève/Documents/cours/NSI/projet-ds/tarme_NMEA_et_deconfinement_oblige/tram_NMEA.py',
                                 wdir='C:/Users/Elève/Documents/cours/NSI/projet-ds/tarme_NMEA_et_deconfinement_oblige')

                                veuillez insérer votre trame NMEA : (sinon entrer) {insérer votre trame içi sans les acolades}
                            </code>
                        </pre>
                    </div>
                </div>
                <div class="row">
                    <p class="explication">
                        Si nous rentrons un texte, celui-ci doit être une trame. Le programme vérifie et si le texte n'est pas une trame, içi le texte est "je ne met pas une trame" donc le programme détecte que ce n'est pas une trame et demande dans ce cas de vérifier la trame ou de pressé entrer pour retourner sur la tram par défaut.
                    </p>
                </div>
                <div class="row">
                    <div class="col-12">
                        <pre>
                            <code class="language-python">
                                In [1]: runfile('C:/Users/Elève/Documents/cours/NSI/projet-ds/tarme_NMEA_et_deconfinement_oblige/tram_NMEA.py',
                                 wdir='C:/Users/Elève/Documents/cours/NSI/projet-ds/tarme_NMEA_et_deconfinement_oblige')

                                veuillez insérer votre trame NMEA : (sinon entrer) je ne met pas une trame

                                trame non valide, veuillez vérifier votre trame puis resaisissez {réecriver votre trame içi ou presser entrer en n'ayant rien saisie}
                            </code>
                        </pre>
                    </div>
                </div>
                <div class="row">
                    <div class="col-12">
                        <p class="explication">
                            Le programme fonctionnera seul et vous ouvrira dans votre navigateur par défaut les 2 cartes exigées le programme s'arrête ; pour le réutiliser il faut le relancer.
                        </p>
                    </div>
                </div>
            </div>
            <script src="prism.js"></script>
            <script src="JS.js"></script>
            <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
            <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
        </body>
    </html>